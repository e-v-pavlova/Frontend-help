<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="utf-8">
    <title>Help</title>
    <link rel="stylesheet" href="./main.css">
</head>

<body>
    <!-- <h1>browser</h1> -->
    <h1>HTML</h1>
    <div>
        <ul>
            <li>Всё состоит из тегов</li>
            <li>теги вложены друг в друга и образуют дерево</li>
            <li>каждому тегу можно задать настройки - атрибуты</li>
        </ul>
        <ul>
            <li> &lt;html&gt; корневой, с него всегда начинаем </li>
            <li> &lt;head&gt; первый элемент в эчтимеэле </li>
            <li> &lt;body&gt; это тело всего видимого</li>
            <li> &lt;meta&gt; настройки страницы </li>
            <li> &lt;title&gt; заголовок страницы в браузере наверху в адресной </li>
            <li> &lt;div&gt; универсал пикчерс </li>
            <li> &lt;h1&gt; заголовок </li>
            <li> &lt;p&gt; параграф, абзац </li>
            <li> &lt;ul&gt; список</li>
            <li> &lt;li&gt; элемент списка </li>
        </ul>
        <ul>
            <li> class="" </li>
            <li> id </li>
        </ul>
    </div>
    <h1>CSS</h1>
    <div>
        <ul>
            <li>CSS - это списки характеристик внешнего вида элементов на странице</li>
            <li>каждый список относится к одному или нескольким элементам</li>
            <li>строка перед списком (селектор) указывает к какому элементу/там он относится</li>
            <li>приоритет стиля определяется, во-первых, словом !important рядом справа, во-вторых, "силой" селектора, -втретьих, расположением ниже по порядку</li>
        </ul>
        <ul>
            <strong>Виды селекторов</strong>
            <li>cелектор по тэгу: div{}</li>
            <li>селектор по классу: .footer-button {}</li>
            <li>селектор по id: #main-menu {}</li>
            <li>селектор по атрибуту: input[name="email"] {}</li>
            <li>cелекторы составные: .footer-button img{}</li> <!--выберет все img внутри любого предка с классом footer-button-->
            <li>cелекторы составные: .footer-button > img{}</li> <!--выберет все img внутри ближайшего родителя с классом footer-button-->
            <li>cелектор специальный*: div.wrapper{}</li> <!--выберет все div с классом wrapper-->
            <li>cелектор двойной(тройной,...)*: .footer-button img, div.wrapper{}</li>
            <li>cелектор очередный*: li + li{}</li> <!--выберет ближайшего соседа li к элементу li-->
        </ul>
        <ul>
            <strong>Базовые стили</strong>
            <li>margin: внешний отступ элемента;</li>
            <li>padding: внутренний отступ элемента;</li>
            <li>border: толщина, стиль, цвет границы элемента;</li>
            <li>font-size: размер шрифта;</li>
            <li>font-weight: насыщенность шрифта;</li>
            <li>font-family: название шрифта;</li>
            <li>width: ширина элемента;</li>
            <li>height: высота элемента;</li>
            <li>max-width: максимально допустимая ширина элемента;</li>
            <li>display: отвечает за то, как элемент будет отображен в документе; (значение flex - делает элементы "гибкими для изменения и распределения пространства между ними в даннм контейнере)</li>
            <li>flex-direction: расположение ряда элементов внутри flex-контейнера; (column-вертикально, row-горизонтально)</li>
            <li>justify-content: выравнивание элементов вдоль главной оси; (center, left, right, space-between, space-around, space-evenly)</li>
            <li>align-items: выравнивание элементов вдоль поперечной оси на текущей линии (stretch, center, baseline, end, start</li>
            <li>flex-grow: определяет способность элемента растягиваться в случае необходимости; (1,2...)</li>
            <li>color: цвет текста элемента;</li>
            <li>background-color: цвет контейнера;</li>
            <li>fill: цвет внутри объекта;</li>
            <li>cursor: форма курсора при наведении на элемент; (pointer)</li>
        </ul>
    </div>
    <h1>Js</h1>
    <div>
        <ul>
            <strong>Переменные</strong>
            <li>let message; (let "объявляет", вводит переменную message)</li>
            <li>const message; (const "объявляет", вводит неизменняемую переменную message)</li>
            <li>message = "hello"; (в переменную поместили данные)</li>
            <li>alert(message); (функция alert вызвала модальное "окошко", содержащее данные переменной message)</li>
        </ul>
        <ul>
            <strong>Типы данных</strong>
            <li> number (числа), целочисленные значения, так и числа с плавающей точкой.</li>
            <li> bigint (целые числа) произвольной длины</li>
            <li> string (строка) 'Строка должна быть заключена в кавычки' </li>
            <li> - 'одинарные'</li>
            <li> - " двойные "</li>
            <li> - `обратные кавычки позволяют встраивать переменные ${str}`</li>
            <li> boolean (логический тип,данетка) true (истина) и false (ложь)</li>
            <li> null (пусто, ничего) </li>
            <li> undefined (не назначено)</li>
            <li> symbol (символ) для уникальных идентификаторов в объектах</li>
            <li> object (объект) для более сложных структур данных</li>
            <li> *typeof , возвращает тип данных переменной</li>
            <li>- typeof x</li>
            <li> - typeof(x)</li>
        </ul>
        <ul>
            <strong> Функции alert, prompt, confirm </strong>
            <li>alert вызывает модально окно с сообщением (т.е. данные переменной, которую положили в эту функцию)</li>
            <li>prompt вызывает окошко с полем для ввода данных пользователем ( Пример: prompt('Сколько тебе лет?', ''); )</li>
            <li>функция может принимать 2 аргумента, первый аргумент содержит вопрос сообщения, второй "" аргумент отображает первоначальное значение в поле ввода, поэтому его можно оставить пустым</li>
            <li>Взаимодействие функций:</li>
            <li>let age = prompt('Сколько тебе лет?', '');<br>alert('Тебе ${age} лет!');</li>
            <li>Функция prompt вызовет окошко с вопросом и полем для ввода, после того как пользователь заполнит данные, функция alert вызовет окошко с сообщением, содержащим данные переменной age, т.е.то что ввел пользователь при выполнении функции prompt</li>
            <li>confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.</li>
            <li>показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.</li>
        </ul>
        <h2> Преобразование типов</h2>
        <ul>
            <li>Строковое – String(value). Для примитивных значений работает очевидным образом.</li>
            <li>_</li>
            <li>Численное – Number(value). Происходит в математических операциях.</li>
            <li>undefined---NaN</li>
            <li>null---0</li>
            <li>true / false---1 / 0</li>
            <li>string---Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.</li>
            <li>_</li>
            <li>Может быть вызвано с помощью Boolean(value).Логическое – Происходит в логических операциях.</li>
            <li>0, null, undefined, NaN, ""---false</li>
            <li>любое другое значение---true</li>

        </ul>
        <h2>Операторы сравнения</h2>
        <ul>
            <li>Результат сравнения имеет логический тип. true false</li>
            <li>_</li>
            <li>Сравнение строк. Чтобы определить, что одна строка больше другой,используется «алфавитный» порядок. Чем ниже, тем больше. Unicode</li>
            <li>_</li>
            <li>Сравнение разных типов. При сравнении значений разных типов JavaScript приводит каждое из них к числу.</li>
            <li>_</li>
            <li>Сравнение с null и undefined</li>
            <li>При строгом равенстве ===
                Эти значения различны, так как различны их типы.</li>
            <li>При нестрогом равенстве ==
                Эти значения равны друг другу и не равны никаким другим значениям.</li>
            <li>При использовании математических операторов и других операторов сравнения < > <= >=
                Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.</li>
            <li>_</li>
            <li>сравнения null и 0</li>
            <li>alert( null > 0 );  // (1) false</li>
            <li>alert( null == 0 ); // (2) false</li>
            <li>alert( null >= 0 ); // (3) true</li>
            <li>_</li>
            <li>Значение undefined несравнимо с другими значениями</li>
            <li>_</li>

        </ul>
        <h2>Логические операторы || (ИЛИ), && (И) и ! (НЕ)</h2>
            <h3>ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.</h3>
            <p>- Вычисляет операнды слева направо.</p>
            <p>- Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.</p>
            <p>- Если все операнды являются ложными (false), возвращает последний из них.</p>
            <h3>И && возвращает первое ложное значение. Или последнее, если ничего не найдено.</h3>
            <p>- Вычисляет операнды слева направо.</p>
            <p>- Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.</p>
            <p>- Если все операнды были истинными, возвращается последний.</p>
            <p>Приоритет оператора && больше, чем у ||</p>
            <h3>НЕ ! Сначала приводит аргумент к логическому типу true/false. Затем возвращает противоположное значение.</h3>
            <p>Двойное НЕ !! используют для преобразования значений к логическому типу. Первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его.</p>
            <p>Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым</p>
    </div>
    <h1>git</h1>
</body>

</html>