<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="utf-8">
    <title>Help</title>
    <link rel="stylesheet" href="./main.css">
    <link rel="stylesheet" href="prism/prism.css"/>
</head>

<body>
    <div id="tool" class="tool">
        <div class="wrapper">
            <button class="tool__button tool__button-opener">Открыть все</button>
            <button class="tool__button tool__button-closer">Закрыть все</button>
        </div>
    </div>
    <!-- <h1 class="chapter-title">browser</h1> -->
    <div class="wrapper">
        <h1 class="chapter-title">HTML</h1>
    </div>
    <section class="wrapper wrapper paragraph">
        <h2 class="paragraph__title">Принципы HTML</h2>
        <div class="paragraph__content paragraph__content_closed">
            <ul>
                <li>Всё состоит из тегов</li>
                <li>Теги вложены друг в друга и образуют дерево</li>
                <li>Каждому тегу можно задать настройки - атрибуты</li>
            </ul>
            <pre>
                <code class="language-html">
                    &lt;!DOCTYPE html&gt;
                    &lt;html&gt;
                        &lt;head&gt;
                            &lt;meta charset=&quot;utf-8&quot;&gt;
                            &lt;title&gt;Моя тестовая страница&lt;/title&gt;
                        &lt;/head&gt;
                        &lt;body&gt;
                            &lt;p&gt;Пример самой простой страницы
                        &lt;/body&gt;
                    &lt;/html&gt;
                </code>
            </pre>
            <a target="_blank" href="https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/HTML_basics">developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/HTML_basics</a>
        </div>
    </section>
    <section class="wrapper wrapper paragraph">
        <h2 class="paragraph__title">Тэги</h2>
        <div class="paragraph__content paragraph__content_closed">
            <ul>
                <li><code class="language-html">&lt;html&gt;&lt;/html&gt;</code> корневой, с него всегда начинаем </li>
                <li><code class="language-html">&lt;head&gt;&lt;/head&gt;</code> первый дочерний элемент в <code class="language-html">&lt;html&gt;</code></li>
                <li><code class="language-html">&lt;meta&gt;</code> настройки страницы </li>
                <li><code class="language-html">&lt;title&gt;&lt;/title&gt;</code> заголовок страницы, отображается в верхней панели браузера и в поисковой выдаче</li>
                <li><code class="language-html">&lt;body&gt;&lt;/body&gt;</code> в этом тэге лежит всё, что видно на странице</li>
                <li><code class="language-html">&lt;div&gt;&lt;/div&gt;</code> универсальный контейнер </li>
                <li><code class="language-html">&lt;h1&gt;&lt;/h1&gt;, &lt;h2&gt;&lt;/h2&gt;, &lt;h3&gt;&lt;/h3&gt;, ...</code> заголовки</li>
                <li><code class="language-html">&lt;p&gt;&lt;/p&gt;</code> параграф, абзац </li>
                <li><code class="language-html">&lt;ul&gt;&lt;/ul&gt;</code> список</li>
                <li><code class="language-html">&lt;li&gt;&lt;/li&gt;</code> элемент списка </li>
                <li><code class="language-html">&lt;a&gt;&lt;/a&gt;</code> ссылка </li>
                <li><code class="language-html">&lt;img&gt; картинка</code> </li>
                <li><code class="language-html">&lt;form&gt;&lt;/form&gt;</code> форма </li>
                <li><code class="language-html">&lt;input&gt;</code> поле ввода </li>
                <li><code class="language-html">&lt;textarea&gt;&lt;/textarea&gt;</code> многострочное поле ввода </li>
            </ul>
            <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/HTML/Element">developer.mozilla.org/ru/docs/Web/HTML/Element</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Атрибуты</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Глобальные - можно использовать для любых тегов:</p>
            <ul>
                <li><code class="language-html">class=""</code></li>
                <li><code class="language-html">id=""</code></li>
                <li><code class="language-html">lang=""</code></li>
                <li><code class="language-html">style=""</code></li>
            </ul>
            <p>Атрибуты, которые подходят только для определенных тегов:</p>
            <ul>
                <li><code class="language-html">href=""</code> (<code class="language-html">&lt;a&gt;&lt;/a&gt;</code>)</li>
                <li><code class="language-html">name=""</code> (<code class="language-html">&lt;button&gt;&lt;/button&gt;, &lt;form&gt;&lt;/form&gt;, &lt;input&gt;, &lt;textarea&gt;&lt;/textarea&gt;</code>)</li>
                <li><code class="language-html">src=""</code> (<code class="language-html">&lt;img&gt;, &lt;input&gt;, &lt;script&gt;&lt;/script&gt;</code>)</li>
                <li><code class="language-html">charset=""</code> (<code class="language-html">&lt;meta&gt;&lt;/meta&gt;, &lt;script&gt;&lt;/script&gt;</code>)</li>
            </ul>
            <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/HTML/Attributes">developer.mozilla.org/ru/docs/Web/HTML/Attributes</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Как правильно верстать</h2>
        <div class="paragraph__content paragraph__content_closed">
            <h3>Придавать контенту структуру и смысл - семантику:</h3>
            <ul>
                <li> Использовать заголовки (<code class="language-html">&lt;h1&gt;&lt;/h1&gt;, &lt;h2&gt;&lt;/h2&gt;, ...</code>), параграфы(<code class="language-html">&lt;p&gt;&lt;/p&gt;</code>), списки (<code class="language-html">&lt;ul&gt;&lt;/ul&gt;</code>) </li>
                <li> Использовать модные семантические теги (<code class="language-html">&lt;article&gt;&lt;/article&gt;, &lt;section&gt;&lt;/section&gt;, &lt;nav&gt;&lt;/nav&gt;, &lt;header&gt;&lt;/header&gt;, &lt;footer&gt;&lt;/footer&gt;</code>)
            </ul>
            <a target="_blank" href="https://htmlacademy.ru/blog/html/semantics">htmlacademy.ru/blog/html/semantics</a>
            <h3>Именовать классы по принципу БЭМ: class="блок__элемент_модификатор"</h3>
            <p>Примеры:</p>
            <pre>
                <code class="language-html">
                    &lt;form class=&quot;search-form search-form_focused&quot;&gt;
                        &lt;input class=&quot;search-form__input&quot;&gt;
                        &lt;button class=&quot;search-form__button&quot;&gt;Найти&lt;/button&gt;
                    &lt;/form&gt;
                </code>
            </pre>
            <pre>
                <code class="language-html">
                    &lt;ul class=&quot;menu&quot;&gt;
                        &lt;li class=&quot;menu__item menu__item_active&quot;&gt;
                            &lt;a class=&quot;menu__link&quot; href=&quot;#&quot;&gt;Пункт 1&lt;/a&gt;
                        &lt;/li&gt;
                        &lt;li class=&quot;menu__item&quot;&gt;
                            &lt;a class=&quot;menu__link&quot; href=&quot;#&quot;&gt;Пункт 2&lt;/a&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                </code>
            </pre>
            <a target="_blank" href="https://ru.bem.info/methodology/quick-start/">ru.bem.info/methodology/quick-start/</a>
        </div>
    </section>
    <div class="wrapper">
        <h1 class="chapter-title">CSS</h1>
    </div>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Принципы CSS</h2>
        <div class="paragraph__content paragraph__content_closed">
            <ul>
                <li>CSS - это списки характеристик внешнего вида элементов на странице</li>
                <li>Каждый список относится к одному или нескольким элементам</li>
                <li>Строка перед списком (селектор) указывает к какому элементу/там он относится</li>
                <li>Приоритет стиля определяется, во-первых, словом !important рядом справа, во-вторых, "силой" селектора, -втретьих, расположением ниже по порядку</li>
            </ul>
            <pre>
                <code class="language-css">
                    h1 {
                        color: red;
                        font-size: 5em;
                    }
                    
                    p {
                        color: black;
                    }
                </code>
            </pre>
            <a target="_blank" href="https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/CSS_basics">developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/CSS_basics</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Селекторы</h2>
        <div class="paragraph__content paragraph__content_closed">
            <ul>
                <li>по тэгу: <code class="language-css">div {}</code></li>
                <li>по классу: <code class="language-css">.footer-button {}</code></li>
                <li>по id: <code class="language-css">#main-menu {}</code></li>
                <li>по атрибуту: <code class="language-css">input[name="email"] {}</code></li>
                <li>через пробел: <code class="language-css">.footer-button img {}</code> (выберет все img внутри любого предка с классом footer-button)</li>
                <li>со знаком ">": <code class="language-css">.footer-button > img {}</code> (выберет все img внутри ближайшего родителя с классом footer-button)</li>
                <li>слитно, без пробела: <code class="language-css">div.wrapper {}</code> (выберет все div с классом wrapper)</li>
                <li>со знаком "+": <code class="language-css">li + li {}</code> (выберет ближайшего соседа li к элементу li)</li>
                <li>несколько селекторов через запятую: <code class="language-css">.footer-button img, div.wrapper {}</code></li>
            </ul>
            <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/Reference#селекторы">developer.mozilla.org/ru/docs/Web/CSS/Reference#селекторы</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Cтили</h2>
        <div  class="paragraph__content paragraph__content_closed">
            <ul>
                <li><code class="language-css">margin</code>: внешний отступ элемента;</li>
                <li><code class="language-css">padding</code>: внутренний отступ элемента;</li>
                <li><code class="language-css">border</code>: толщина, стиль, цвет границы элемента;</li>
                <li><code class="language-css">font-size</code>: размер шрифта;</li>
                <li><code class="language-css">font-weight</code>: насыщенность шрифта;</li>
                <li><code class="language-css">font-family</code>: название шрифта;</li>
                <li><code class="language-css">width</code>: ширина элемента;</li>
                <li><code class="language-css">height</code>: высота элемента;</li>
                <li><code class="language-css">max-width</code>: максимально допустимая ширина элемента;</li>
                <li><code class="language-css">color</code>: цвет текста элемента;</li>
                <li><code class="language-css">background-color</code>: цвет контейнера;</li>
                <li><code class="language-css">cursor</code>: форма курсора при наведении на элемент; (pointer)</li>
                <li><code class="language-css">display</code>: отвечает за то, как элемент будет отображен в документе (значение flex - делает элементы "гибкими для изменения и распределения пространства между ними в данном контейнере); </li>
                <li><code class="language-css">flex-direction</code>: расположение ряда элементов внутри flex-контейнера (column-вертикально, row-горизонтально); </li>
                <li><code class="language-css">justify-content</code>: выравнивание элементов вдоль главной оси внутри flex-контейнера (center, left, right, space-between, space-around, space-evenly); </li>
                <li><code class="language-css">align-items</code>: выравнивание элементов вдоль поперечной оси на текущей линии внутри flex-контейнера (stretch, center, baseline, end, start);</li>
                <li><code class="language-css">flex-grow</code>: определяет способность элемента растягиваться в случае необходимости (1,2...); </li>
            </ul>
            <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/Reference#справочный_указатель">developer.mozilla.org/ru/docs/Web/CSS/Reference#справочный_указатель</a>
        </div>
    </section>
    <div class="wrapper">
        <h1 class="chapter-title">Js</h1>
    </div>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Переменные</h2>
        <div class="paragraph__content paragraph__content_closed">
            <ul>
                <li><code class="language-js">let message;</code> (let "объявляет", вводит переменную message)</li>
                <li><code class="language-js">const message;</code> (const "объявляет", вводит неизменняемую переменную message)</li>
                <li><code class="language-js">message = "hello";</code> (в переменную поместили данные)</li>
                <li><code class="language-js">alert(message);</code> (функция alert вызвала модальное "окошко", содержащее данные переменной message)</li>
            </ul>
            <a target="_blank" href="https://learn.javascript.ru/variables">learn.javascript.ru/variables</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Типы данных (их 8)</h2>
        <div class="paragraph__content paragraph__content_closed">
            <h3>Примитивные</h3>
            <ul>
                <li>1) <strong>number</strong> (числа), целочисленные значения, так и числа с плавающей точкой.</li>
                <li>2) <strong>bigint</strong> (большие целые числа) произвольной длины</li>
                <li>3) <strong>string</strong> (строка) 'Строка должна быть заключена в кавычки' 
                    <ul>
                        <li>'одинарные'</li>
                        <li>" двойные "</li>
                        <li>`обратные кавычки позволяют встраивать переменные <code class="language-js">${str}`</code></li>
                    </ul>
                </li>
                <li>4) <strong>boolean</strong> (логический тип,данетка) <code class="language-js">true</code> (истина) и <code class="language-js">false</code> (ложь)</li>
                <li>5) <strong>null</strong> (пусто, ничего) </li>
                <li>6) <strong>undefined</strong> (не назначено)</li>
                <li>7) <strong>symbol</strong> (символ) для уникальных идентификаторов в объектах</li>
            </ul>
            <h3>8) object (объект) для более сложных структур данных</h3>
            <p>Отличается от примитивных типов</p>
            <p>Если значение переменной примитивного типа, значит оно лежит прямо в этой переменной, с объектом не так - в переменной лежит не сам объект, а только ссылка на него. </p>
            <h3>Оператор typeof</h3>
            <p>Возвращает тип данных переменной - <code class="language-js">typeof x</code>, <code class="language-js">typeof(x)</code></p>
            <a target="_blank" href="https://learn.javascript.ru/types">learn.javascript.ru/types</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title"> Преобразование типов</h2>
        <div class="paragraph__content paragraph__content_closed">
            <table>
                <tr>
                    <th></th>
                    <th>Преобразование к строке</th>
                    <th>Преобразование к числу</th>
                    <th>Преобразование к логическому значению</th>
                </tr>
                <tr>
                    <td>Когда происходит в Js автоматически?</td>
                    <td>Пример: функция alert (<code class="language-js">alert(123)</code> преобразует число 123 в строку "123" и выведет "123")</td>
                    <td>В математических вычислениях (<code class="language-js">"6" / "2"</code> преобразует строки в числа, вычислит и вернет 3)</td>
                    <td>
                        <ul>
                            <li>В логических операциях ( <code class="language-js">5 && "Hello"</code> преобразует 5 в true, "Hello" в true, и вернет "Hello"</li>
                            <li>В сравнениях (<code class="language-js">true < 2</code> преобразует true в 1, сравнит 1 < 2 и вернет true)</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Как вызвать самостоятельно?</td>
                    <td><code class="language-js">String(value)</code></td>
                    <td>
                        <ul>
                            <li><code class="language-js">Number(value)</code></li>
                            <li><code class="language-js">+value</code></li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li><code class="language-js">Boolean(value)</code></li>
                            <li><code class="language-js">!!value</code></li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Некоторые конкретные случаи</td>
                    <td>
                        <ul>
                            <li><code class="language-js">123</code> &#8594; <code class="language-js">"123"</code></li>
                            <li><code class="language-js">true</code> &#8594; <code class="language-js">"true"</code></li>
                            <li><code class="language-js">undefined</code> &#8594; <code class="language-js">"undefined"</code></li>
                        </ul>
                        
                    </td>
                    <td>
                        <ul>
                            <li><code class="language-js">"  123  "</code> &#8594; <code class="language-js">123</code> (пробелы по краям обрезаются)</li>
                            <li><code class="language-js">"twentytwo"</code> &#8594; <code class="language-js">NaN</code></li>
                            <li><code class="language-js">true</code> &#8594; <code class="language-js">1</code></li>
                            <li><code class="language-js">false</code> &#8594; <code class="language-js">0</code></li>
                            <li><code class="language-js">undefined</code> &#8594; <code class="language-js">NaN</code></li>
                            <li><code class="language-js">null</code> &#8594; <code class="language-js">0</code></li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li><code class="language-js">"", 0, null, undefined, NaN</code> &#8594; <code class="language-js">false</code></li>
                            <li>любое другое значение &#8594; <code class="language-js">true</code></li>
                        </ul>
                    </td>
                </tr>
            </table>
            <a target="_blank" href="https://learn.javascript.ru/type-conversions">learn.javascript.ru/type-conversions</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Функции alert, prompt, confirm </h2>
        <div class="paragraph__content paragraph__content_closed">
            <h3>alert</h3>
            <p>Вызывает модально окно с сообщением (выведет то, что передали в качестве параметра при вызове функции)</p>
            <p>Функция alert ничего не возвращает</p>
            <h3>prompt</h3>
            <p>Вызывает окошко с полем для ввода данных пользователем ( <code class="language-js">prompt('Сколько тебе лет?', '');</code> )</p>
            <p>Функция может принимать 2 аргумента, первый аргумент содержит вопрос сообщения, второй - первоначальное значение в поле ввода, поэтому его можно оставить пустым ("") или вообще не задавать</p>
            <p>Возвращает строку - то, что пользователь ввел в поле ввода</p>
            <h3>сonfirm</h3>
            <p>Отображает модальное окно с текстом вопроса и двумя кнопками: OK и Отмена.</p>
            <p>Возвращает <code class="language-js">true</code>, если нажата OK, и <code class="language-js">false</code>, если нажата кнопка «Отмена» или Esc с клавиатуры.</p>
            <a target="_blank" href="https://learn.javascript.ru/alert-prompt-confirm">learn.javascript.ru/alert-prompt-confirm</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Базовые математические операторы</h2>
        <div class="paragraph__content paragraph__content_closed">
            <ul>
                <li>- (вычитание)</li>
                <li>+ (сложение)</li>
                <li>* (умножение)</li>
                <li>/ (деление)</li>
                <li>% (взятие остатка от деления: 5 % 2, будет 1)</li>
                <li>** (возведение в степень: 2**3, будет 8)</li>
                <li>= (присваивание)</li>
                <li>- (унарный минус, пример: -5)</li>
            </ul>
            <p>Примеры особенностей взаимодействия с операторами:</p>
            <ul>
                <li><code class="language-js">"ты" + "я" //"тыя"</code> (при сложении строки слепливаются)</li>
                <li><code class="language-js">"1" + 2 //"12"</code> (когда одно из двух слогаемых строка, второе преобразуется в строку)</li>
                <li><code class="language-js">2 + 2 + "1" //"41"</code> (сначала выполнится сложение чисел 2 + 2, затем выполнится сложение со строкой 4 + "1")</li>
                <li><code class="language-js">+true //1</code> (унарный + преобразует не числовой операнд в число)</li>
            </ul>
            <p>У операторов есть приоритетность, например, умножение выполнится раньше сложения</p>
            <a target="_blank" href="https://learn.javascript.ru/operators">learn.javascript.ru/operators</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Cравнения >, <, >=, <=, ==, ===</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Результат сравнения имеет логический тип. <code class="language-js">true</code> <code class="language-js">false</code></p>
            <h3>Сравнение строк.</h3>
            <p><code class="language-js"></code>'abc' < 'abd' //true (та строка считается больше, которая ниже в таблице Unicode</p>
            <h3>Сравнение значений разных типов.</h3>
            <p>Если сравниваюся два примитива разных типов: Js приведет их оба к числам</p>
            <ul>
                <li><code class="language-js">true < '5' //(1 < 5)? true</code></li>
                <li><code class="language-js">'01' == 1 //(1 == 1)? true</code></li>
                <li><code class="language-js">false == 0 //(0 == 0)? true</code></li>
                <li><code class="language-js">true == 2 - '1' //(true == true)? true</code></li>
            </ul>
            <p>Если сравниваеся примитив с объектом: Js приведет объект либо к числу, либо к строке</p>
            <ul>
                <li><code class="language-js">[] == 0 //(0 == 0)? true</code></li>
                <li><code class="language-js">[] == '0' //('' == '0')? false</code></li>
            </ul>
            <h3>Особые правила при сравнении с null и undefined</h3>
            <p>При сравнении через "==" undefined и null ни к чему не приводятся, они равны друг другу и не равны ничему другому</p>
            <ul>
                <li><code class="language-js">null == undefined //true</code></li>
                <li><code class="language-js">null == 0 //false</code></li>
                <li><code class="language-js">undefined == NaN //false</code></li>
            </ul>
            <p>При сравненияx <, >, <=, >= поведение стандартное: null преобразуются к числу 0, а undefined – к числу NaN (см. пункт "Сравнение значений разных типов")</p>
            <ul>
                <li><code class="language-js">null > 0 //(0 > 0)? false</code></li>
                <li><code class="language-js">null >= 0 //(0 >= 0)? true</code></li>
                <li><code class="language-js">undefined >= 0 //(NaN >= 0)? false</code></li>
            </ul>
            <h3>NaN - единственное значение, которое не равно самому себе</h3>
            <ul>
                <li><code class="language-js">NaN === NaN // false</code></li>
                <li><code class="language-js">NaN !== NaN // true</code></li>
            </ul>
            <p>Поэтому для проверки, является ли число NaN, нужно использовать Number.isNaN() или isNaN()</p>
            <a target="_blank" href="https://learn.javascript.ru/comparison">learn.javascript.ru/comparison</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Конструкция if</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Конструкция if ( условие ) { команда; } вычисляет условие в скобках () и, если результат true, то выполняет блок кода в скобках {}</p>
            <p>К ветке if () {} можно добавлять дополнительные ветки else if () {} и else {}:</p>
            <pre>
                <code class="language-js">
                    let y = prompt('Введи число', '');
                    if (y < 0) {
                    alert( 'Число отрицательное' );
                    } else if (y > 0) {
                    alert( 'Число положительное' );
                    } else {
                    alert( 'Это число ноль' );
                    }
                </code>
            </pre>
            <p>Есть сокращенная запись конструкции if - через условный оператор "?":</p>
            <pre>
                <code class="language-js">
                    let y = prompt('Введи число', '');
                    let x = (y < 0) ? "Число отрицательное" : (y > 0) ? "Число положительное" : "Это число ноль";
                    alert(x);
                </code>
            </pre>
            <p>Запись через "?" подходит не всегда</p>
            <a target="_blank" href="https://learn.javascript.ru/ifelse">learn.javascript.ru/ifelse</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Конструкция switch</h2>
        <div class="paragraph__content paragraph__content_closed">
            <ul>
                <li>может быть всегда переписана на if</li>
                <li>содержит один и более блоков case и необязательный блок default (он выполнится, если ни один из кейсов не соответствует)</li>
                <li>команда break прерывает выполнение всего свича; eсли в конце кейса не поставить break, то выполнение пойдёт ниже по следующим командам, игнорируя даже проверки кейсов</li>
            </ul>
            <pre>
                <code class="language-js">
                    let a = 2 + 2;
                    switch (a) {
                        case 3:
                            alert( 'Маловато' );
                            break;
                        case 4:
                            alert( 'В точку!' );
                            break;
                        case 5:
                            alert( 'Перебор' );
                            break;
                        default:
                            alert( "Нет таких значений" );
                        }
                    }
                </code>
            </pre>
            <a target="_blank" href="https://learn.javascript.ru/switch">learn.javascript.ru/switch</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Логические операторы || (ИЛИ), && (И), ! (НЕ)</h2>
        <div class="paragraph__content paragraph__content_closed">
            <h3>|| (ИЛИ)</h3>
            <p><code class="language-js">undefined || null || 0</code>&nbsp;&nbsp;&nbsp;(вернет 0)</p>
            <ul>
                <li>слева направо по очереди операнды переводятся в логические значения</li>
                <li>как только найдется true, выполнение останавливается и возвращается исходное значение этого операнда</li>
                <li>если true так и не нашлось, возвращается значение последнего операнда</li>
            </ul>
            <h3>&& (И)</h3>
            <p><code class="language-js">1 && 2 && null && 3</code>&nbsp;&nbsp;&nbsp;(вернет null)</p>
            <ul>
                <li>слева направо по очереди операнды переводятся в логические значения</li>
                <li>как только найдется false, выполнение останавливается и возвращается исходное значение этого операнда</li>
                <li>если false так и не нашлось, возвращается значение последнего операнда</li>
            </ul>
            <h3>! (НЕ)</h3>
            <p><code class="language-js">!!null</code>&nbsp;&nbsp;&nbsp;(вернет false)</p>
            <p>сначала приводит аргумент к логическому типу true/false, затем возвращает противоположное значение.</p>
            <p>Приоритеты операторов: сначала выполняется ! , потом &&, потом ||.</p>
            <a target="_blank" href="https://learn.javascript.ru/logical-operators">learn.javascript.ru/logical-operators</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Оператор два вопроса ??</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p><code class="language-js">undefined ?? 'Bob'</code>&nbsp;&nbsp;&nbsp;(вернет 'Bob')</p>
            <p>Возвращает первый из аргументов, который окажется не null и не undefined</p>
            <pre>
                <code class="language-js">
                    let firstName = null;
                    let lastName = null;
                    let nickName = "Суперкодер";
                    alert(firstName ?? lastName ?? nickName ?? "Аноним"); // выведет "Суперкодер"
                </code>
            </pre>
            <a target="_blank" href="https://learn.javascript.ru/nullish-coalescing-operator">learn.javascript.ru/nullish-coalescing-operator</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Циклы while и for</h2>
        <div class="paragraph__content paragraph__content_closed">
            <ul>
                <li> while – Проверяет условие перед каждой итерацией.</li>
                <li> do..while – Проверяет условие после каждой итерации.</li>
                <li> for (;;) – Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.</li>
            </ul>
            <p>Чтобы организовать бесконечный цикл, используют конструкцию <code class="language-js">while (true)</code>. При этом он, как и любой другой цикл, может быть прерван директивой <code class="language-js">break</code>.<br>

                Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву <code class="language-js">continue</code>.<br>
                
                Обе этих директивы поддерживают метки, которые ставятся перед циклом. Метки – единственный способ для <code class="language-js">break/continue</code> выйти за пределы текущего цикла, повлиять на выполнение внешнего.<br>
                
                Заметим, что метки не позволяют прыгнуть в произвольное место кода, в JavaScript нет такой возможности.</p>
            <h3>Цикл While</h3>
            <pre>
                <code class="language-js">
                    while (condition) {
                      // код
                      // также называемый "телом цикла"
                    }
                </code>
            </pre>
            <p>
                Код из тела цикла выполняется, пока условие condition истинно.<br>
                Например, цикл ниже выводит i, пока i < 3:<br>
            </p>  
            <pre>
                <code class="language-js">
                    let i = 0;
                    while (i < 3) { // выводит 0, затем 1, затем 2
                        alert( i );
                        i++;
                    }
                </code>
            </pre>
            <p>Одно выполнение тела цикла по-научному называется <em>итерация</em>. Цикл в примере выше совершает три итерации.<br>
            Если бы строка i++ отсутствовала в примере выше, то цикл бы повторялся (в теории) вечно. На практике, конечно, браузер не позволит такому случиться, он предоставит пользователю возможность остановить «подвисший» скрипт, а JavaScript на стороне сервера придётся «убить» процесс.<br>
            Любое выражение или переменная может быть условием цикла, а не только сравнение: условие while вычисляется и преобразуется в логическое значение.<br>
            Например, while (i) – более краткий вариант while (i != 0):</p>
            <h3>Фигурные скобки не требуются для тела цикла из одной строки</h3>
            <pre>
                <code class="language-js">
                    let i = 3;
                    while (i) alert(i--);
                </code>
            </pre>
            <h3>Цикл «do…while»</h3>
            <p>Проверку условия можно разместить под телом цикла, используя специальный синтаксис <code>do..while</code>:
            </p>
            <pre>
                <code class="language-js">
                    do {
                        // тело цикла
                    } while (condition);
                </code>
            </pre>
            <p>Цикл сначала выполнит тело, а затем проверит условие <code>condition</code>, и пока его значение равно <code>true</code>, он будет выполняться снова и снова.
            </p>
            <p>Например:</p>
            <pre>
                <code class="language-js">
                    let i = 0;
                    do {
                      alert( i );
                      i++;
                    } while (i < 3);
                </code>
            </pre>
            <p>Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось <strong>хотя бы один раз</strong>, даже если условие окажется ложным. На практике чаще используется форма с предусловием: <code>while(…) {…}</code>.</p>    
            <h3>Цикл «for»</h3>
            <pre>
                <code class="language-js">
                    for (начало; условие; шаг) {
                        // ... тело цикла ...
                    }
                </code>
            </pre>
            <pre>
                <code class="language-js">
                    for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
                        alert(i);
                    }
                </code>
            </pre>
            <p>В целом, алгоритм работы цикла выглядит следующим образом:</p>
            <pre>
                <code class="language-js">
                    Выполнить начало
                    → (Если условие == true → Выполнить тело, Выполнить шаг)
                    → (Если условие == true → Выполнить тело, Выполнить шаг)
                    → (Если условие == true → Выполнить тело, Выполнить шаг)
                    → ...
                </code>
            </pre>
            <p>Вот в точности то, что происходит в нашем случае:</p>
            <pre>
                <code class="language-js">
                    // for (let i = 0; i < 3; i++) alert(i)

                    // Выполнить начало
                    let i = 0;
                    // Если условие == true → Выполнить тело, Выполнить шаг
                    if (i < 3) { alert(i); i++ }
                    // Если условие == true → Выполнить тело, Выполнить шаг
                    if (i < 3) { alert(i); i++ }
                    // Если условие == true → Выполнить тело, Выполнить шаг
                    if (i < 3) { alert(i); i++ }
                    // ...конец, потому что теперь i == 3
                </code>
            </pre>
            <h3>Встроенное объявление переменной</h3>
            <p>В примере переменная счётчика i была объявлена прямо в цикле. Это так называемое «встроенное» объявление переменной. Такие переменные существуют только внутри цикла.</p>
            <pre>
                <code class="language-js">
                    for (let i = 0; i < 3; i++) {
                      alert(i); // 0, 1, 2
                    }
                    alert(i); // ошибка, нет такой переменной
                </code>
            </pre>
            <p>Вместо объявления новой переменной мы можем использовать уже существующую:</p>
            <pre>
                <code class="language-js">
                    let i = 0;

                    for (i = 0; i < 3; i++) { // используем существующую переменную
                      alert(i); // 0, 1, 2
                    }
                    
                    alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла
                </code>
            </pre>
            <h3>Пропуск частей «for»</h3>
            <p>Мы можем пропустить начало если нам ничего не нужно делать перед стартом цикла.</p>
            <pre>
                <code class="language-js">
                    let i = 0; // мы уже имеем объявленную i с присвоенным значением

                    for (; i < 3; i++) { // нет необходимости в "начале"
                      alert( i ); // 0, 1, 2
                    }
                </code>
            </pre>
            <p>Можно убрать и шаг:</p>
            <pre>
                <code class="language-js">
                    let i = 0;

                    for (; i < 3;) {
                      alert( i++ );
                    }
                </code>
            </pre>
            <p>
                Это сделает цикл аналогичным while (i < 3).<br>
                А можно и вообще убрать всё, получив бесконечный цикл:<br>
                При этом сами точки с запятой ; обязательно должны присутствовать, иначе будет ошибка синтаксиса.
            </p>
            <h3>Прерывание цикла: «break»</h3>
            <p>
                Обычно цикл завершается при вычислении условия в false.<br>

                Но мы можем выйти из цикла в любой момент с помощью специальной директивы break.<br>
                
                Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем – выдаёт:<br>
            </p>
            <pre>
                <code class="language-js">
                    let sum = 0;

                    while (true) {
                    
                      let value = +prompt("Введите число", '');
                    
                      if (!value) break; // (*)
                    
                      sum += value;
                    
                    }
                    alert( 'Сумма: ' + sum );
                </code>
            </pre>
            <p>
                Директива break в строке (*) полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на alert.<br>

                Вообще, сочетание «бесконечный цикл + break» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале или конце цикла, а посередине или даже в нескольких местах его тела.<br>
            </p>
            <h3>Переход к следующей итерации: continue</h3>
            <p>
                Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).<br>

                Её используют, если понятно, что на текущем повторе цикла делать больше нечего.<br>
                
                Например, цикл ниже использует continue, чтобы выводить только нечётные значения:<br>
            </p>
            <pre>
                <code class="language-js">
                    for (let i = 0; i < 10; i++) {

                        // если true, пропустить оставшуюся часть тела цикла
                        if (i % 2 == 0) continue;
                      
                        alert(i); // 1, затем 3, 5, 7, 9
                    }
                </code>
            </pre>
            <p>
                Для чётных значений i, директива continue прекращает выполнение тела цикла и передаёт управление на следующую итерацию for (со следующим числом). Таким образом alert вызывается только для нечётных значений.
            </p>
            <h3>Директива continue позволяет избегать вложенности</h3>
            <p>Цикл, который обрабатывает только нечётные значения, мог бы выглядеть так:</p>
            <a target="_blank" href="https://learn.javascript.ru/while-for">learn.javascript.ru/nullish-coalescing-operator</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Алгоритм выведения простых чисел из заданного интервала</h2>
        <div class="paragraph__content paragraph__content_closed">
            <pre>
                <code class="language-js" class="paragraph__content paragraph__content_closed">
                    let res = [];
                    let end = prompt("До какого числа проверить?", "");
                    for (let i = 1; i <= end; i++) { 
                        for (let j = 2; j < i; j++) { //Проверяем число i на простоту
                            if (i % j == 0) {
                                break;
                            }
                            if (j == i-1) {  
                                res.push(i);
                            }
                        }
                    }
                    alert(res);
                </code>
            </pre>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Копирование объектов Object.assign</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Переменная, которой присвоен объект, хранит не сам объект, а «ссылку» на него.</p>
            <pre>
                <code class="language-js">
                    let a = {}; // создали пустой объект, в переменную а положили ссылку на него
                    let b = a; // копирование по ссылке, теперь в переменной b ссылка на тот же самый объект
                    alert( a == b ); // true, в переменных лежат одинаковые ссылки
                </code>
            </pre>
            <h3>Метод Object.assign()</h3>
            <p>Копирует значения полей из исходных объектов в целевой объект и возвращает целевой объект (в нем уже будут все скопированные поля).</p>
            <pre>
                <code class="language-js">
                    let user = {
                        name: "John"
                    };
                    let permissions1 = {
                        canView: true
                    };
                    let permissions2 = {
                        canEdit: true
                    };
                    console.log( Object.assign(user, permissions1, permissions2) ); // копируем все свойства из permissions1 и permissions2 в user(целевой объект) и выводим его в консоль
                </code>
            </pre>
            <p>Часто встречается на практике: клонирование объекта c помощью Object.assign()</p>
            <pre>
                <code class="language-js">
                    let user = {
                        name: "John",
                        age: 30
                    };
                    let clone = Object.assign({}, user); // создали новый пустой объект, скопировали в него все свойства из user и записали ссылку на него в переменную clone
                </code>
            </pre>
            <a target="_blank" href="https://learn.javascript.ru/object-copy">learn.javascript.ru/object-copy</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Метод объекта</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Объект является не примитивным методом, содержащим в себе не обязательный список свойств.</p>
            <p>Пустой объект можно создать 2 способами:</p>
            <pre>
                <code class="language-js">
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"
                </code>
            </pre>
            <p>В пустой объект можно поместить неограниченное количество свойств со значениями (См.пример ниже). Если имя свойтсва состоит из нескольких слов, то оно заключается в кавычки</p>
            <p>К свойству обращаются через точку -  user.name, при обращении к свойству из нескольких слов используют скобки user["natural materials"]</p>
            <p>Свойство можно удалить с помощью команды delete, а его значение можно переназначать</p>
            <p>Для проверки наличия свойства в объекте используют оператор in ("key" in obj)</p>
            <pre>
                <code class="language-js">
let user = { name: "John", age: 30 };
alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует
                </code>
            </pre>
            <p>Для перебора всех свойств объекта используется цикл for..in</p>
            <pre>
                <code class="language-js">
for (key in object) {
// тело цикла выполняется для каждого свойства объекта
}
                </code>
            </pre>
            <p>Объекты имеют вид:</p>
            <pre>
                <code class="language-js">
                    let user = { //в переменной user лежит ссылка на данный объект
                        name: "John", //name - поле(свойство), строка "John" - значение этого поля
                        age: 30,
                        getName() { //getName - поле, значение которого функция; такое поле называется методом
                            console.log(this.name);
                        },
                    };
                    //в переменной user теперь лежит ссылка на только что созданный объект

                    user.getName() //вызов метода; выведет "John"
                </code>
            </pre>
            <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#defining_methods">developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#defining_methods</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Ключевое слово this</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>this всегда указывает на объект (this - это ссылка на объект).</p>
            <p>На какой именно объект указывает this? (см. пример ниже)</p>
            <ul>
                <li>В глобальном контексте выполнения (за пределами каких-либо функций) this ссылается на глобальный объект Window (см. строку 23)</li>
                <li>Если вызвать обычную функцию (не метод какого-нибудь объекта), то this внутри неё ссылается на Window (см. строку 24)</li>
                <li>Если вызвать метод объекта, то this внутри него ссылается на этот самый объект, от которого вызван метод (см. строки 25, 26)</li>
                <li>Если вызвать функцию в теле метода, то this внутри неё ссылается на Window (см. строку 14. Потому что функция a() на строке 14 вызвана без указания объекта, подобно тому, как вызвана функция getThis() на строке 24)</li>
                <li>Если вызвать стрелочную функцию в теле метода, то this внутри неё ссылается на родительский объект (см. строку 19. Потому что стрелочная функция особенная. В этом и есть ее важное отличие от обычной функции. Функцию b как будто бы вызывали не просто вот так: "b()", а от объекта: "myObject.b()")</li>
            </ul>
            <pre>
                <code class="language-js">
                    1   function getThis() {
                    2       console.log(this);
                    3   }
                    4
                    5   let myObject = {
                    6       myMethod1() {
                    7          console.log(this);
                    8       },
                    9       myMethod2: getThis, //в метод myMethod мы положили ссылку на функцию getThis
                    10       myMethod3() {
                    11          let a = function() {
                    12             console.log(this)
                    13          };
                    14          a();
                    15
                    16          let b = () => {
                    17              console.log(this);
                    18          };
                    19          b();
                    20      },
                    21  };
                    22
                    23  console.log(this);    //выведет объект Window
                    24  getThis();            //выведет объект Window
                    25  myObject.myMethod1(); //выведет объект, от которого вызван myMethod1:  {myMethod1: ..., myMethod2: ..., myMethod3: ...}
                    26  myObject.myMethod2(); //выведет объект, от которого вызван myMethod2:  {myMethod1: ..., myMethod2: ..., myMethod3: ...}
                    27  myObject.myMethod3(); //выведет сначала объект Window, затем объект, от которого вызван myMethod3
                </code>
            </pre>
            <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this">developer.mozilla.org/this</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Функция-конструктор new</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>1. Имя функции-конструктора должно начинаться с большой буквы</p>
            <p>2. Bыполняется только с помощью оператора "new"</p>
            <p>Когда функция вызывается как new User(...), происходит следующее:</p>
            <ul>
                <li>Создаётся новый пустой объект, и он присваивается this</li>
                <li>Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства (поля)</li>
                <li>Возвращается значение this</li>
            </ul>
            <pre>
                <code class="language-js">
                    function User() { //создали функцию указывая будущие поля объекта через "this"
                        this.name = "Ron";
                        this.age = 5;
                    }
                    
                    let user = new User(); //создается пустой объект с полями name(значение "Ron"), age(значение 5)
                                        //ccылка на объект помещается в переменную user
                </code>
            </pre>
            <a target="_blank" href="https://learn.javascript.ru/constructor-new">learn.javascript.ru/constructor-new</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">const, let и var</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Для объявления(назначения) переменной используются ключевые слова let, const или var(в старых скриптах)</p>
            <p></p>
            <table>
                <tr>
                    <th></th>
                    <th>var a</th>
                    <th>let a, const b</th>
                  </tr>
                  <tr>
                    <td>Время создания</td>
                    <td>С 1995 года</td>
                    <td>С 2015 года</td>
                  </tr>
                  <tr>
                    <td>Видимость переменной:</td>
                    <td>Блок кода(а - видна вне блока):
                        <pre>
                            <code class="language-js">
                                { 
                                var a = 1;
                                }
                            </code>
                        </pre>
                        <p>Функция(a - не видна вне функции):</p>
                        <pre>
                            <code class="language-js">
                                function x(){ 
                                var a = 1;
                                }
                            </code>
                        </pre>
                    </td>
                    <td>Блок кода(a,b - не видны вне блока):
                        <pre>
                            <code class="language-js">
                                { 
                                let a = 1;
                                const b = 1;
                                }
                            </code>
                        </pre>
                        <p>Функция(a,b - не видны вне функции):</p>
                        <pre>
                            <code class="language-js">
                                function x(){ 
                                let a = 1;
                                const b = 1;
                                }
                            </code>
                        </pre>
                    </td>
                  </tr>
                  <tr>
                    <td>Условия задания переменной</td>
                    <td>До/после задания переменной
                        <pre>
                            <code class="language-js">
                                сonsole.log(a); // undefined
                                var a = 1;
                                сonsole.log(a); // 1
                            </code>
                        </pre>
                    </td>
                    <td>До/после задания переменной
                        <pre>
                            <code class="language-js">
                                сonsole.log(a); // error: a is not defined
                                сonsole.log(b); // error: b is not defined
                                let a = 1;
                                const b = 2;
                                сonsole.log(a); // 1
                                сonsole.log(b); // 2
                            </code>
                        </pre>
                    </td>
                  </tr>
                  <tr>
                    <td>Если задать переменную дважды с одинаковым именем</td>
                    <td>Не выдает ошибки
                        <pre>
                            <code class="language-js">
                                var a = 1;
                                var a = 2;
                                сonsole.log(a); // 2
                            </code>
                        </pre>
                    </td>
                    <td>Выдает ошибку
                        <pre>
                            <code class="language-js">
                                let x = 1;
                                let x = 2;
                                console.log(x) // Identifier 'x' has already been declared
                                const y = 1;
                                let y = 2;
                                console.log(y) // Identifier 'y' has already been declared
                            </code>
                        </pre>
                    </td>
                  </tr>
            </table>
            <a target="_blank" href="https://habr.com/ru/company/ruvds/blog/420359/">habr.com/ru/company/ruvds/blog/420359</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Методы для примитивов</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Все примитивы, кроме null и undefined, предоставляют множество полезных методов, которые работают с помощью временных объектов (их создает и удаляет автоматически сам JS)</p>
            <p>Данные объекты называются: String, Number, Boolean, Symbol и BigInt и вызываются в заивисмости от типа данных примитива.</p>
            <pre>
                <code class="language-js">
                    let str = "Привет";
                    сonsole.log( str.toUpperCase() ); // ПРИВЕТ
                </code>
            </pre>
            <p> В коде выше происходит следующее:</p>
            <ul>
                <li>1. str- примитив типа строка. В момент обращения к ней создается специальный объект String, который принимает значение строки и применяет имеющийся у него метод toUpperCase()</li>
                <li>2. метод работает и выводит новое значение</li>
                <li>3. специальный бъект удаляется, оставляя только примитив</li>
            </ul>
            <h3>Методы для строк</h3>
                <ul>
                    <li>toLowerCase - преобразует символы сроки в нижний регистр ("Привет" => "привет")</li>
                    <li>toUpperCase - преобразует символы сроки в верхний регистр ("Привет" => "ПРИВЕТ")</li>
                    <li>concat - объединяет строки и возвращает одну получившуюся ("При".concat("вет") => "Привет")</li>
                    <li>split - разбивает строку в массив по указанному разделителю ("hey".split("") => ["h","e","y"], "Oh yess".split(" ") => ["oh", "yess"])</li>
                    <li>repeat - повторяет строку, в параметрах число повторений ("Я".repeat(3) => "Я Я Я")</li>
                    <li>charAt - возвращает символ по индексу, указанному в параметрах ("Привет".charAt(2) => "в")</li>
                    <li>slice - извлекает часть строки по индексам (min, max) ("Привет".slice(2,5) => "иве")</li>
                </ul>
                <p>Другие методы объекта String:
                    <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">developer.mozilla.org/Web/JS/Reference/Global_Objects/String</a>
                </p>
            <h3>Методы для чисел</h3>
            <ul>
                <li>Math.floor - Округление в меньшую сторону (3.1 => 3; -1.1 => -2)</li>
                <li>Math.ceil - Округление в большую сторону (3.1 => 4; -1.1 => -1)</li>
                <li>Math.round - Округление до ближайшего целого (3.1 => 3; 3.6 => 4; -1.1 => -1)</li>
            </ul>
                <p>Наиболее втречаемая ошибка при вычислении - потеря точности (числа хранятся в бинарной форме(1/0), в которой десятичные дроби предтавляются бесконечными)</p>
                <pre>
                    <code class="language-js">
                        (0.1 + 0.2 == 0.3 ); // false
                        alert( 0.1 + 0.2 ); // 0.30000000000000004
                    </code>
                </pre>
                <p>Другие методы объекта Number:
                    <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Numbers_and_dates">developer.mozilla.org/Web/JS/Guide/Numbers_and_dates</a>
                </p>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Массивы</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Каждый массив является особым объектом и предназначен для хранения упорядоченной коллекции данных (любого типа)</p>
            <p>Массив задается двумя способами</p>
            <pre>
                <code class="language-js">
                    let arr = new Array(..., item, ...); //не подходит для создания массива с одним элементом-числом
                    let arr = [..., item, ...];
                </code>
            </pre>
            <p>Вызов элементов осуществляют по индексу: arr[1] = 'item'</p>
            <p>Длину массива определяют через поле length (arr.length)</p>
            <h3>Перебор элементов массива</h3>
            <p>Для перебора элементов в массиве используют цикл for... по индексам:</p>
            <pre>
                <code class="language-js">
                    let arr = ["Яблоко", "Апельсин", "Груша"];
                    for (let i = 0; i < arr.length; i++) {
                        alert( arr[i] );
                    }
                </code>
            </pre>
            <p>Другой цикл for...of не предоставляет доступа к индексу элемента, только к значению</p>
            <pre>
                <code class="language-js">
                    let arr = ["Яблоко", "Апельсин", "Груша"];
                    for (let key in arr) {
                    alert( arr[key] ); // Яблоко, Апельсин, Груша
                    }
                </code>
            </pre>
            <h3>Методы массивов</h3>
            <p>Для добавления/ удаления элементов</p>
            <ul>
                <li>arr.push() – добавляет элементы в конец</li>
                <li>arr.pop() – извлекает элемент из конца</li>
                <li>arr.shift() – извлекает элемент из начала</li>
                <li>arr.unshift() – добавляет элементы в начало</li>
                <li>splice(индекс, число элементов, "элемент") – начиная с индекса, удаляет (число) элементов и вставляет "элемент"</li>
                <li>slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end)</li>
                <li>concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items</li>
            </ul>
            <p>Для поиска среди элементов</p>
            <ul>
                <li>indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.</li>
                <li>includes("элемент") – возвращает true, если в массиве имеется "элемент", в противном случае false</li>
                <li>find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true</li>
            </ul>
            <p>Для преобразования массива</p>
            <ul>
                <li>map(func) – создаёт новый массив из результатов вызова func для каждого элемента</li>
                <li>sort(func) – сортирует массив «на месте», а потом возвращает его</li>
                <li>reduce/reduceRight(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.</li>
            </ul>
            <p>Проверка массива</p>
            <ul>
                <li>Array.isArray(arr) - проверяет, является ли arr массивом</li>
            </ul>
            <a target="_blank" href="https://learn.javascript.ru/array-methods">learn.javascript.ru/array-methods</a> 
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Функции</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Функции - минипрограммы, выполняющие определенные задачи.</p>
            <p>Состоят из: имени функции, параметров(аргументов), инструкции функции, заключенные в скобки {}</p>
            <p>Функции назначаются тремя способами:</p>
            <ul>
                <li>1. Function Declaration  function sum(a, b) {return a + b};</li>
                <li>2. Function Expression let sum = function(a, b) {return a + b};</li>
                <li>3. Стрелочные функции let sum = (a, b) => a + b</li>
            </ul>
            <p>Для того, чтобы функция заработала, ее необходио вызвать, для этого пишем имя функции и угазываем аргументы в скобках</p>
            <ul>
                <li>Вызов функции ДО ее назначения возможен только у способа назначения Declaration, в других случаях он ПОСЛЕ</li>
                <li>Имя функции должно передавать суть того, что она делает</li>
                <li>В качестве аргумента может быть передан элемент(ы) любого типа данных</li>
                <li>Инструкции функции - код, который выполняет определенные действия на странице при вызове функции</li>
            </ul>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Планирование: setTimeout и setInterval</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Необходимы для вызова функции не в данный момент, а через заданный интервал времени.</p>
            <ul>
                <li>setTimeout позволяет вызвать функцию один раз через определённый интервал времени.</li>
                <li>setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.</li>
            </ul>
            <p>setTimeout</p>
            <pre>
                <code class="language-js">
                    let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);
                </code>
            </pre>
            <p>Параметры:</p>
            <ul>
                <li>func|code - Функция или строка кода для выполнения. Обычно это функция.</li>
                <li>delay - Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.</li>
                <li>arg1, arg2… - Аргументы, передаваемые в функцию</li>
            </ul>
            <p>setInterval</p>
            <pre>
                <code class="language-js">
                    let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);
                </code>
            </pre>
            <p>Функция повторяется через указанный интервал времени. Чтобы остановить дальнейшее выполнение функции, необходимо вызвать clearInterval(timerId)</p>
            <pre>
                <code class="language-js">
// повторить с интервалом 2 секунды
let timerId = setInterval(() => alert('tick'), 2000);

// остановить вывод через 5 секунд
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);
                </code>
            </pre>
            <p>В примере выше сообщение 'tick' будет выводиться каждые 2 секунды, но это действие прекратится через 5 секунд с собщением 'stop'</p>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Замыкание функций</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Под замыканием понимается:</p>
            <ul>
                <li>функция первого класса, в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции во внешнем коде и не являющиеся её параметрами.</li>
                <li>функция, у которой есть доступ к своей внешней функции по области видимости, даже после того, как внешняя функция прекратилась</li>
            </ul>
            <p>Когда код функции хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении({...}), затем во внешнем, затем в следующем и так далее, до глобального.</p>
            <pre>
                <code class="language-js">
                    function person() {
                        let name = 'Peter';
                        
                        return function displayName() {
                          console.log(name);
                        };
                      }
                      let peter = person();
                      peter(); // выведет 'Peter'
                    </code>
                </pre>
            <p>Вызываем функцию person, она возвращает внутреннюю функцию displayName и сохраняет эту ее в переменную peter. Когда мы вызываем функцию peter (ссылается к функции displayName), имя “Peter” выводится в консоль.
                Но переменной с именем name в displayName нет, это работает за счет доступа этой функции к переменной своей внешней функции person, даже после того, как та функция выполнится. Т.о. displayName - замыкание.</p>
                <a target="_blank" href="https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898">medium.com/@stasonmars/понимаем-замыкания-в-javascript</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Дата и время</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Существует встроенный объект Date, он содержит в себе дату и время</p>
            <p>let now = new Date(); //теперь в переменной now содержится текущая дата и время</p>
            <p>Если мы хоти задать конкретную дата и время, то передаем данные в качестве аргументов функции:</p>
            <pre>
                <code class="language-js">    
                    new Date(year, month, date, hours, minutes, seconds, ms)

                    new Date(2022, 12, 03, 20, 00, 00, 00) // 3 Dec 2022, 20:00:00
                </code>
            </pre>
            <p>Методы получения элементов объекта Date</p>
            <ul>
                <li>getFullYear() //получить 4 цифры года</li>
                <li>getMonth() //получить месяц от 0 до 11</li>
                <li>getDate() //получить день месяцаот 1 до 31</li>
                <li>getHours(), getMinutes(), getSeconds(), getMilliseconds()</li>
                <li>getDay() //получить день недели 0-6(вс-сб)</li>
            </ul>
            <p>Методы установки элементов даты</p>
            <ul>
                <li>setFullYear(year, [month], [date])</li>
                <li>setMonth(month, [date])</li>
                <li>setDate(date)</li>
                <li>setHours(hour, [min], [sec], [ms]), setMinutes(min, [sec], [ms]), setSeconds(sec, [ms]), setMilliseconds(ms)</li>
                <li>getDay() //получить день недели 0-6(вс-сб)</li>
            </ul>
            <p>Даты можно вычитать, и разность возвращается в миллисекундах. Так происходит, потому что при преобразовании в число объект Date становится таймстампом.</p>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">JSON</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>JSON (JavaScript Object Notation) – это общий формат для представления значений и объектов.</p>
            <p>JavaScript предоставляет методы:</p>
            <ul>
                <li>1) JSON.stringify для преобразования объектов в JSON.</li>
                <li>2) JSON.parse для преобразования JSON обратно в объект.</li>
            </ul>
            <pre>
                <code class="language-js">
                    let student = {
                        name: 'John',
                        age: 30,
                        isAdmin: false,
                        courses: ['html', 'css', 'js'],
                        wife: null
                    };
                      
                    let json = JSON.stringify(student);
                      
                    alert(typeof json); // мы получили строку!
                      
                    alert(json);
                      /* выведет объект в формате JSON:
                    {
                        "name": "John",
                        "age": 30,
                        "isAdmin": false,
                        "courses": ["html", "css", "js"],
                        "wife": null
                    }
                    */
                </code>
            </pre>
            <p>Отличия от объектного литерала:</p>
            <ul>
                <li>1) Строки используют двойные кавычки. Никаких одинарных кавычек или обратных кавычек в JSON. Так 'John' становится "John".</li>
                <li>2) Имена свойств объекта также заключаются в двойные кавычки. Это обязательно. Так age:30 становится "age":30.</li>
            </ul>
            <p>JSON поддерживает типы данных: объекты, массивы, числа, строки, null, булевые значения</p>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Стили и классы</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Cуществует два способа задания стилей для элемента:</p>
            <ul>
                <li>1. Создать класс в CSS и использовать его: 
                    <pre>
                        <code class="language-html">
                            &lt;div class="..."&gt;&lt;/div&gt;
                        </code>
                    </pre></li>
                <li>2. Писать стили непосредственно в атрибуте style:
                <pre>
                    <code class="language-html">
                        &lt;div style="..."&gt;&lt;/div&gt;
                    </code>
                </pre></li>
            </ul>
            <p>Для управления классами существуют два DOM-свойства:</p>
            <ul>
                <li>className – строковое значение, удобно для управления всем набором классов.</li>
                <li>classList – объект с методами add/remove/toggle/contains, удобно для управления отдельными классами.</li>
            </ul>
            <p>Изменение классов.</p>
            <ul>
                <li>Для классов было введено схожее свойство "className": elem.className соответствует атрибуту "class".</li>
                <li>Если мы присваиваем что-то elem.className, то это заменяет всю строку с классами.</li>
                <li>elem.classList – это специальный объект с методами для добавления/удаления одного класса.</li>
                <li>Мы можем работать как со строкой полного класса, используя className, так и с отдельными классами, используя classList.</li>
            </ul>
            <p>Методы classList:</p>
            <ul>
                <li>elem.classList.add/remove("class") – добавить/удалить класс.</li>
                <li>elem.classList.toggle("class") – добавить класс, если его нет, иначе удалить.</li>
                <li>elem.classList.contains("class") – проверка наличия класса, возвращает true/false.</li>
            </ul>
            <p>Для чтения окончательных стилей (с учётом всех классов, после применения CSS и вычисления окончательных значений) используется:</p>
            <ul>
                <li>Метод getComputedStyle(elem, [pseudo]) возвращает объект, похожий по формату на style.</li>
            </ul>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Поиск: getElement*, querySelector*</h2>
        <div class="paragraph__content paragraph__content_closed">
            <p>Если у элемента есть атрибут id, то мы можем получить его вызовом document.getElementById(id)</p>
            <pre>
                <code class="language-js">
                    let elem = document.getElementById('id');
                </code>
            </pre>
            <p>Самый универсальный метод поиска – это elem.querySelectorAll(css), он возвращает все элементы внутри elem, удовлетворяющие данному CSS-селектору.</p>
            <pre>
                <code class="language-js">
                    let elements = document.querySelectorAll('ul > li:last-child'); // в переменной теперь все элементы &lt;li&gt;, которые являются последними потомками в &lt;ul>&gt;&lt;/ul&gt;
                </code>
            </pre>
            <p>Метод elem.querySelector(css) возвращает первый элемент, соответствующий данному CSS-селектору. результат такой же, как при вызове elem.querySelectorAll(css)[0]</p>
            <p>Метод elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.</p>
            <pre>
                <code class="language-js">
                    // может быть любая коллекция вместо document.body.children
                    for (let elem of document.body.children) {
                        if (elem.matches('a[href$="zip"]')) {
                            alert("Ссылка на архив: " + elem.href );
                        }
                    }
                </code>
            </pre>
            <p>Метод elem.closest(css) ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск. Он поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден.</p>
            <pre>
                <code class="language-js">
&lt;h1&gt;Содержание&lt;/h1&gt;
&lt;div class="contents"&gt;
    &lt;ul class="book"&gt;
        &lt;li class="chapter"&gt;Глава 1&lt;/li&gt;
        &lt;li class="chapter"&gt;Глава 2&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;script&gt;
    let chapter = document.querySelector('.chapter'); // LI
    alert(chapter.closest('.book')); // UL
    alert(chapter.closest('.contents')); // DIV
    alert(chapter.closest('h1')); // null (потому что h1 - не предок)
&lt;/script&gt;
                </code>
            </pre>
        </div>
    </section>
    <div class="wrapper">
        <h1 class="chapter-title">Git</h1>
    </div>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Установка программы git</h2>
        <div class="paragraph__content paragraph__content_closed">
            <ul>
                <li>Скачать git <a target="_blank" href="https://git-scm.com">https://git-scm.com</a></li>
                <li>git --version (посмотреть, какая версия git установлена)</li>
            </ul>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Настройка git после установки (один раз)</h2>
        <div class="paragraph__content paragraph__content_closed">
            <ul>
                <li>git config --global user.name «My Name» (задать своё имя, оно будет использоваться в каждом коммите)</li>
                <li>git config --global user.email myemail@example.com (задать свою почту, она будет использоваться в каждом коммите)</li>
                <li>git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin" (задать, какой текстовый редактор git должен использовать; по умолчанию это редактор Vim)</li>
                <li>git config --list (посмотреть все конфигурационные настройки)</li>
            </ul>
            <a target="_blank" href="https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup">git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Начало работы с git</h2>
        <div class="paragraph__content paragraph__content_closed">
            <ul>
                <li>git init (создать git репозиторий(.git); из какой папки вызвана команда, там и будет создана подпапка .git), а затем "связать" этот репозиторий с github (как(?), см. следующий параграф)</li>
                <li>либо: git clone https://github.com/my-github-username/my-repo (скачать git репозиторий из интернета; при этом будет автоматически установлена "связь" удаленного репозитория и только что появившегося локального)</li>
                <li>git remote show origin (посмотреть адрес удаленного репозитория, с которым "связан" локальный)</li>
            </ul>
            <a target="_blank" href="https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository">git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Как "связать" локальный git репозиторий с github</h2>
        <div class="paragraph__content paragraph__content_closed">
            <ul>
                <li>
                    <div>1. git remote show origin (посмотреть адрес удаленного репозитория, с которым "связан" локальный) - если локальный репозиторий ещё не "связан" с удаленным, то будет так:</div>
                    <img src="images/git-remote-show-origin.png" alt="git remote show origin">
                </li>
                <li>
                    <div>2. На <a href="https://github.com">github.com</a> создать новый репозиторий (пустой):</div>
                    <ul>
                        <li>
                            <div>Кнопка для начала создания:</div>
                            <img src="images/github-new-repo-button.png" alt="github new repository button">
                        </li>
                        <li>
                            <div>Настройки ("Initialize this repository with" не надо):</div>
                            <img src="images/github-new-repo-settings.png" alt="github new repository settings">
                        </li>
                        <li>
                            <div>Подсказка от гитхаба, что делать дальше:</div>
                            <img src="images/github-new-repo-prompt.png" alt="github new repository prompt">
                        </li>
                    </ul>
                </li>
                <li>
                    <div>3. Для "связки" своего локального репозитория с только что созданным на гитхабе, выполнить команды из подсказки (в терминале из локальной папки):</div>
                    <ul>
                        <li>git remote add origin https://github.com/e-v-pavlova/test.git (указать адрес удаленного репозитория)</li>
                        <li>git branch -M main (не обязательно; измененить имя текущей локальной ветки на "main" (было "master"); это имя требуется в следующей команде)</li>
                        <li>git push -u origin main (отправить данные из локального репозитория в удаленный; флаг "-u" позволит гиту запомнить настройку "origin main", благодаря чему при последующих отправках данных достаточно будет выполнять краткую команду "git push" вместо "git push origin main")</li>
                    </ul>
                </li>
                <p>Готово!</p>
            </ul>
            <a target="_blank" href="https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes">git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes</a>
        </div>
    </section>
    <section class="wrapper paragraph">
        <h2 class="paragraph__title">Запись изменений в git репозиторий</h2>
        <div class="paragraph__content paragraph__content_closed">
            <ul>
                <li>git pull (скачать данные с удаленного репозитория)</li>
                <li>
                    <div>git status (проверить статус файлов)</div>
                    <div>Зеленым выделены отслеживаемые файлы (готовые к коммиту), красным - неотслеживаемые:</div>
                    <img src="images/git-status.png" alt="git status">
                </li>
                <li>
                    <div>git add index.html (добавить файл index.html в отслеживание - подготовить к коммиту)</div>
                    <div>git add . (когда нужно добавить сразу несколько файлов)</div>
                </li>
                <li>git restore --staged index.html (убрать файл index.html из отслеживания)</li>
                <li>git commit -m "add Git Recording Changes paragraph" (закоммитить изменения в отслеживаемых файлах, т.е. записать эти изменения в историю гита в папку .git)</li>
                <li>git push (отправить изменения на удаленный репозиторий)</li>
            </ul>
            <a target="_blank" href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository">git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository</a>
        </div>
    </section>
    <script src="./main.js"></script>
    <script src="prism/prism.js"></script>
    <script src="prism/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <script type="text/javascript">
        Prism.plugins.NormalizeWhitespace.setDefaults({
            'remove-trailing': true,
            'remove-indent': true,
            'left-trim': true,
            'right-trim': true,
        });
    </script>
</body>

</html>